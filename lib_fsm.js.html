<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/fsm.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">HOME</a></h2><h2><a href="api-overview.html">API OVERVIEW</a></h2><h3>Modules</h3><ul><li><a href="module-app_controller.html">app/controller</a></li><li><a href="module-lib_fsm.html">lib/fsm</a></li><li><a href="module-lib_json.html">lib/json</a><ul class='methods'><li data-type='method'><a href="module-lib_json.html#.deserialize">deserialize</a></li><li data-type='method'><a href="module-lib_json.html#.serialize">serialize</a></li></ul></li><li><a href="module-lib_layoutFsm.html">lib/layoutFsm</a></li><li><a href="module-lib_utils_descriptor.html">lib/utils/descriptor</a></li><li><a href="module-lib_utils_iterator.html">lib/utils/iterator</a><ul class='methods'><li data-type='method'><a href="module-lib_utils_iterator.html#.empty">empty</a></li><li data-type='method'><a href="module-lib_utils_iterator.html#.flatten">flatten</a></li><li data-type='method'><a href="module-lib_utils_iterator.html#.hijack">hijack</a></li><li data-type='method'><a href="module-lib_utils_iterator.html#.wrap">wrap</a></li></ul></li></ul><h3>Classes</h3><ul><li><a href="module-lib_fsm-Fsm.html">lib/fsm~Fsm</a></li><li><a href="module-lib_fsm-Fsm-State.html">lib/fsm~Fsm~State</a><ul class='methods'><li data-type='method'><a href="module-lib_fsm-Fsm-State.html#.add">add</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-State.html#.all">all</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-State.html#.remove">remove</a></li></ul></li><li><a href="module-lib_fsm-Fsm-Symbol.html">lib/fsm~Fsm~Symbol</a><ul class='methods'><li data-type='method'><a href="module-lib_fsm-Fsm-Symbol.html#.add">add</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-Symbol.html#.all">all</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-Symbol.html#.remove">remove</a></li></ul></li><li><a href="module-lib_fsm-Fsm-Transition.html">lib/fsm~Fsm~Transition</a><ul class='methods'><li data-type='method'><a href="module-lib_fsm-Fsm-Transition.html#.add">add</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-Transition.html#.all">all</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-Transition.html#.get">get</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-Transition.html#.groups">groups</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-Transition.html#.remove">remove</a></li><li data-type='method'><a href="module-lib_fsm-Fsm-Transition.html#.select">select</a></li></ul></li><li><a href="module-lib_layoutFsm-Fsm.html">lib/layoutFsm~Fsm</a></li><li><a href="module-lib_layoutFsm-Fsm-State.html">lib/layoutFsm~Fsm~State</a></li><li><a href="module-lib_layoutFsm-Fsm-Symbol.html">lib/layoutFsm~Fsm~Symbol</a><ul class='methods'><li data-type='method'><a href="module-lib_layoutFsm-Fsm-Symbol.html#.add">add</a></li><li data-type='method'><a href="module-lib_layoutFsm-Fsm-Symbol.html#.getFromLabel">getFromLabel</a></li><li data-type='method'><a href="module-lib_layoutFsm-Fsm-Symbol.html#.remove">remove</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/fsm.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module lib/fsm
 * @requires lib/utils/iterator
 * @requires lib/utils/descriptor
 */
import * as utilsIterator from "./utils/iterator";
import {check, checkNow} from "./utils/check";

/**
 * @param {?module:lib/fsm~Cfg} cfg
 */
export default function fsm(cfg) {
  return new Fsm(cfg);
}

/**
 * @callback SymbolsMixin
 * @param {Class} FsmSymbol
 * @return {Class} Should be a class */
/**
 * @callback StatesMixin
 * @param {Class} FsmState
 * @return {Class} Should be a class */
/**
 * @callback TransitionsMixin
 * @param {Class} FsmTransition
 * @return {Class} Should be a class */
/**
 * @typedef {mdn:Object} module:lib/fsm~Cfg
 * @property {?mdn:Object} mixins
 * @property {module:lib/fsm~SymbolsMixin} mixins.symbols=identity
 * @property {module:lib/fsm~StatesMixin} mixins.states=identity
 * @property {module:lib/fsm~TransitionsMixin} mixins.transitions=identity
 * @property {?mdn:Object} descriptor
 * @property {mdn:Array} descriptor.symbols=[]
 * @property {mdn:Array} descriptor.states=[]
 * @property {mdn:Array} descriptor.transitions=[]
 */

/**
 * @constructor
 * @param {module:lib/fsm~Cfg} cfg={}
 * @protected
 */
function Fsm(cfg) {

  cfg = check().definition({
    mixins: check().definition({
      symbols: check().ifWrongType("function").default(identity),
      states: check().ifWrongType("function").default(identity),
      transitions: check().ifWrongType("function").default(identity)
    }),
    descriptor: check().definition({
      symbols: check().array()(
        check().definition({})
      ),
      states: check().array(
        check().definition({})
      ),
      transitions: check().array(
        check().definition({})
      ),
    })
  });

  cfg = normalizeCfg(cfg);

  // Data

  // symbols: Map of:
  //   - keys: symbols ; let `a` be the key
  //   - values: objects with:
  //     - transitions: Set of transitions, where `by = a`
  // states: Map of:
  //  - keys: states ; let `k` be the key
  //  - values: objects with:
  //    - initial: boolean
  //    - final: boolean
  //    - pred : Map of: 
  //      - keys: symbols ; let `a` be the key
  //      - values: Set of transitions, where `to = k` and `by = a`
  //    - succ: Map of:
  //      - keys: states ; let `s` be the key
  //      - values: Map of:
  //        - keys: symbols ; let `a` be the key
  //        - values: transition, where `to = s`, `from = k` and `by = a`
  // transitions: Map of:
  //   - keys: transitions
  //   - values: objects with:
  //     - from: state
  //     - to: state
  //     - by: symbol

  const data = {
    symbols: new Map(),
    states: new Map(),
    transitions: new Map()
  };

  const struct = this;

  // API

  /**
   * @class
   * @memberof module:lib/fsm~Fsm
   * @inner
   * @protected
   */
  class Symbol {
    /**
     * The accessor of the finite state machine owning the symbol.
     * @type {module:lib/fsm} 
     * @readonly
     */
    get struct() { return struct; }
    /**
     * Iterates on the symbols owned by the finite state machine.
     * @return {Iterator.&lt;module:lib/fsm~Fsm~Symbol>} an iterator of every symbol
     */
    static all() { return getSymbols(data); }
    /**
     * Creates a symbol, adds it to the finite state machine and returns it.
     *
     * The symbol has the prototype of the calling class.
     * @return {module:lib/fsm~Fsm~Symbol} the newly created symbol
     */
    static add(...args) {
      return addSymbol({}, new this(...args), symbol);
    } 
    /**
     * Removes a symbol and its associated transitions. Chainable.
     *
     * If there is no such symbol, the function silently fails and still
     * returns the accessor.
     * @param {module:lib/fsm~Fsm~Symbol} symbol - symbol to remove
     * @return {module:lib/fsm} the accessor of the finite state machine
     */
    static remove(symbol) {
      symbol = checkNow(symbol)
      .ifNotMember((a) => symbols.has(a))
      .done();
      removeSymbol(symbol, data);
      return struct;
    }
  };

  /**
   * @class
   * @memberof module:lib/fsm~Fsm
   * @inner
   * @protected
   */
  class State {
    /**
     * The accessor of the finite state machine owning the symbol
     * @type {module:lib/fsm} 
     * @readonly
     */
    get struct() { return struct; }
    /**
     * Whether the state is initial
     * @type {boolean} 
     * @readonly
     */
    get initial() { return data.states.get(this).initial; }
    /**
     * Whether the state is terminal
     * @type {boolean} 
     * @readonly
     */
    get terminal() { return data.states.get(this).terminal; }
    /**
     * @return {Iterator.&lt;module:lib/fsm~Fsm~State>} every state
     */
    static all() { return getStates(data); }
    /**
     * Removes a state and the associated transitions
     * @param {module:lib/fsm~Fsm~State} state - state to remove
     * @return {module:lib/fsm} the finite state machine
     */
    static remove(state) {
      state = checkNow(state)
      .ifNotMember((s) => states.has(s))
      .done();
      removeState(state, data);
      return struct;
    }
    /**
     * Creates and adds a state
     * @param {?Object} descriptor state descriptor
     * @param {?boolean} descriptor.initial false if omitted
     * @param {?boolean} descriptor.terminal false if omitted
     * @return {module:lib/fsm~Fsm~Transition} the newly created state
     */
    static add(descriptor, ...args) {
      descriptor = checkNow(descriptor)
      .definition({
        initial: check()
        .ifWrongType("boolean")
        .default(false),
        terminal: check()
        .ifWrongType("boolean")
        .default(false),
      });
      return addState(descriptor, new this(...args), data);
    }
  };

  /**
   * @class
   * @memberof module:lib/fsm~Fsm
   * @inner
   * @protected
   */
  class Transition {
    /**
     * The accessor of the finite state machine that owns the transition
     * @type {module:lib/fsm} 
     * @readonly
     */
    get struct() { return struct; }
    /**
     * The source of the transition
     * @type {module:lib/fsm~Fsm~State} 
     * @readonly
     */
    get from() { return data.transitions.get(this).from; }
    /**
     * The target of the transition
     * @type {module:lib/fsm~Fsm~State} 
     * @readonly
     */
    get to() { return data.transitions.get(this).to; }
    /**
     * The symbol of the transition
     * @type {module:lib/fsm~Fsm~State} 
     * @readonly
     */
    get by() { return data.transitions.get(this).by; }
    /**
     * @return {Iterator.&lt;module:lib/fsm~Fsm~Transition>} every transition
     */
    static all() { return getTransitions(data); }
    /**
     * Get a transition
     * @function
     * @param {Object} descriptor
     * @param {!module:lib/fsm~Fsm~State} descriptor.from source
     * @param {!module:lib/fsm~Fsm~State} descriptor.to target
     * @param {!module:lib/fsm~Fsm~Symbol} descriptor.by symbol
     * @return {module:lib/fsm~Fsm~Transition}
     * @throws {TypeError} Will throw if the descriptor is invalid
     */
    static get(descriptor) {
      descriptor = checkNow(descriptor)
      .definition({
        from: check()
        .ifMissing()
        .ifNotMember((s) => data.states.has(s)),
        to: check()
        .ifMissing()
        .ifNotMember((s) => data.states.has(s)),
        by: check()
        .ifMissing()
        .ifNotMember((a) => data.symbols.has(a))
      });
      return getTransition(descriptor.from, descriptor.to, descriptor.by, data);
    }

    /**
     * Creates and adds a transition
     *
     * If an equivalent transition already exists, the function returns it
     * (thus failing silently)
     * @param {Object} descriptor
     * @param {!module:lib/fsm~Fsm~State} descriptor.from source
     * @param {!module:lib/fsm~Fsm~State} descriptor.to target
     * @param {!module:lib/fsm~Fsm~Symbol} descriptor.by symbol
     * @return {module:lib/fsm~Fsm~Transition} the newly created transition
     */
    static add(descriptor, ...args) {
      descriptor = checkNow(descriptor)
      .definition({
        from: check()
        .ifMissing()
        .ifNotMember((s) => data.states.has(s)),
        to: check()
        .ifMissing()
        .ifNotMember((s) => data.states.has(s)),
        by: check()
        .ifMissing()
        .ifNotMember((a) => data.symbols.has(a))
      });
      return addTransition(descriptor, new this(...args), data);
    }
    /**
     * Removes a transition
     * @param {module:lib/fsm~Fsm~Transition} transition - transition to remove
     * @return {module:lib/fsm} the finite state machine
     */
    static remove(transition) {
      removeTransition(transition);
      return struct;
    }
    /**
     * Creates an iterator of transitions that match the selector attributes
     * @param {Object} selector
     * @param {?module:lib/fsm~Fsm~State} selector.from source
     * @param {?module:lib/fsm~Fsm~State} selector.to target
     * @param {?module:lib/fsm~Fsm~Symbol} selector.by symbol
     * @return {Iterator.&lt;module:lib/fsm~Fsm~Transition>} the selected transitions
     */
    static select(selector) {
      selector = checkNow(selector)
      .definition({
        from: check()
        .ifNotMember((s) => data.states.has(s)),
        to: check()
        .ifNotMember((s) => data.states.has(s)),
        by: check()
        .ifNotMember((a) => data.symbols.has(a))
      });
      let args = [];
      let getter = getTransitions;
      if(selector.from != null) {
        getter = getter.from;
        args.push(selector.from);
      }
      if(selector.to != null) {
        getter = getter.to;
        args.push(selector.to);
      }
      if(selector.by != null) {
        getter = getter.by;
        args.push(selector.by);
      }
      args.push(data);
      return getter.apply(null, args);
    }

    /**
     * Creates nested iterators
     * The transitions are first split by their source state, then their target
     * states
     * @return {Iterator.&lt;Iterator.&lt;Iterator.&lt;module:lib/fsm~Fsm~Transition>>>} the collection
     */
    static groups() { return getTransitions.groups(data); }
  };

  Symbol = cfg.mixins.symbols(Symbol);
  State = cfg.mixins.states(State);
  Transition = cfg.mixins.transitions(Transition);

  /**
   * @type {Class}
   */
  this.symbols = Symbol;
  /**
   * @type {Class}
   */
  this.states = State;
  /**
   * @type {Class}
   */
  this.transitions = Transition;
};

// Logic

// Conventions:
//   - `a` is a symbol ; `as` is a collection of symbols
//   - `s` is a state ; `ss` is a collection of states
//   - `t` is a transition ; `ts` is a collection of transitions
//   - `sf` is a source state (state from)
//   - `st` is a target state (state to)

const identity = (x) => x;

const addSymbol = (o, symbolClass, data) => {
  o.tran = new Set();
  const a = new symbolClass(cfg);
  data.symbols.set(a, o);
  return a;
};

const addState = (o, stateClass, data) => {
  o.succ = new Map();
  o.pred = new Map();
  const s = new stateClass(cfg);
  data.states.set(s, o);
  return s;
};

const addTransition = (o, {symbols, states, transitions}, transitionClass) => {
  const succ = states.get(o.from).succ;
  let as = succ.get(o.to);
  if(as == null) {
    as = new Map();
    succ.set(o.to, as);
  }
  let t = as.get(o.by);
  if(t == null) {
    t = new transitionClass(cfg);
    as.set(o.by, t);
    const pred = states.get(o.to).pred;
    let ts = pred.get(o.by);
    if(ts == null) {
      ts = new Set();
      pred.set(o.by, ts);
    }
    ts.add(t);
    symbols.get(o.by).tran.add(t);
    transitions.set(t, o);
  };
  return t;
};

const getTransition = (sf, st, a, data) => {
  let as = data.states.get(sf).succ.get(st);
  if(as == null) return null;
  return as.get(a);
};

const getSymbols = (data) => data.symbols.keys();

const getStates = (data) => data.states.keys();

const getTransitions = (data) => data.transitions.keys();

getTransitions.groups = () => utilsIterator.apply(
  data.states.entries(),
  ([sf, map1]) => {
    const iter = utilsIterator.apply(
      map1.entries(),
      ([st, map2]) => {
        const subiter = map2.values();
        subiter.to = st;
        return subiter;
      }
    );
    iter.from = sf;
    return iter;
  }
);

getTransitions.from = (sf) => utilsIterator.flatten(
  data.states.get(sf).succ.values(),
  (map) => map.values()
);

getTransitions.to = (st) => states.get(st).pred.values();

getTransitions.by = (a) => symbols.get(a).transitions.values();

getTransitions.from.to = (sf, st) => states.get(sf).succ.get(st).values();

getTransitions.to.by = (st, a) => states.get(st).pred.get(a).values();

getTransitions.from.by = (sf, a) => utilsIterator.flatten(
  states.get(sf).succ.values(),
  (map) => {
    let t = map.get(a);
    if(t == null) {
      return utilsIterator.empty();
    }
    return utilsIterator.wrap(t);
  }
);

getTransitions.from.to.by = (sf, st, a, data) => {
  const t = getTransition(sf, st, a, data);
  if(t == null) {
    return utilsIterator.empty();
  }
  return utilsIterator.wrap(t);
};

const removeSymbol = (a, data) => {
  for(let t of getTransitions.by(a)) {
    const o = data.transitions.get(t);
    data.states.get(o.from).succ.get(o.from).delete(a);
    data.states.get(o.to).pred.delete(a);
    data.transitions.delete(t);
  }
  data.symbols.delete(a);
};

const removeState = (s, data) => {
  for(let t of getTransitions.to(s)) {
    const o = data.transitions.get(t);
    data.states.get(o.to).succ.delete(s);
    data.symbols.get(o.by).transitions.delete(t);
    data.transitions.delete(t);
  }
  for(let t of getTransitions.from(s)) {
    const o = data.transitions.get(t);
    data.states.get(o.from).pred.get(o.by).delete(t);
    data.symbols.get(o.by).transitions.delete(t);
    data.transitions.delete(t);
  }
  data.states.delete(s);
};

const removeTransition = (t, data) => {
  const o = data.transitions.get(t);
  if(o != null) {
    data.states.get(o.from).succ.get(o.to).delete(o.by);
    data.states.get(o.to).pred.get(o.by).delete(t);
    data.symbols.get(o.by).transitions.delete(t);
    data.transitions.delete(t);
  }
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Apr 14 2016 15:27:39 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
